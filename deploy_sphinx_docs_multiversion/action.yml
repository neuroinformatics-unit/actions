name: 'Deploy Sphinx Docs Multi_version'
description: 'Deploys pre-built sphinx docs with versioning on GitHub Pages'

inputs: 
  secret_input:
    description: 'The secret input for the GitHub token'
    required: true
  use-make:
    description: |
      Specify whether `make` is used in the `build_sphinx_docs` action,
      so that the correct publish directory is used
    required: false
    type: boolean
    default: false
  switcher-url:
    description: |
      The URL to the switcher.json file that will be updated with the new version.
    required: true

runs:
  using: 'composite'
  steps:
  - name: Checkout repository
    uses: actions/checkout@v4

  - name: Clear previous build if present
    shell: bash
    run: rm -rf ./docs/build

  - name: Download the content for deployment
    uses: actions/download-artifact@v4
    with:
      name: docs-build
      path: ./docs/build

  - name: Checkout the gh-pages branch in a separate folder
    uses: actions/checkout@v4
    with:
      ref: gh-pages
      # Checkout to this folder instead of the current one
      path: deploy
      # Download the entire history
      fetch-depth: 0

  - name: Push the built HTML to gh-pages
    shell: bash 
    run: |
      # Detect if this is a release or from the main branch
      echo "Event name: ${{ github.event_name }}"
      echo "Ref type: ${{ github.ref_type }}"
      if [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref_type }}" = "tag" ]; then
          # Get the tag name without the "refs/tags/" part
          version="${GITHUB_REF#refs/*/}"
      else
          version=dev
      fi

      echo "Deploying version: $version"
      # Make the new commit message. Needs to happen before cd into deploy
      # to get the right commit hash.
      message="Deploy $version from $(git rev-parse --short HEAD)"
      cd deploy
      # Need to have this file so that Github doesn't try to run Jekyll
      touch .nojekyll

      # Add redirection from root url to latest
      echo '<meta http-equiv="Refresh" content="0;url=latest/index.html"/>' > index.html

      # Delete all the files and replace with our new  set
      echo -e "\nRemoving old files from previous builds of ${version}:"
      rm -rvf ${version}
      echo -e "\nCopying HTML files to ${version}:"

      if [[ "${{ inputs.use-make }}" == "true" ]]; then
        BUILD_DIR="../docs/build/html"
      else
        BUILD_DIR="../docs/build"
      fi
      
      cp -Rvf $BUILD_DIR ${version}/

      SWITCHER_URL="${{ inputs.switcher-url }}"
      
      if curl --output /dev/null --silent --head --fail "$SWITCHER_URL"; then
        # File exists, fetch content
        SWITCHER_CONTENT=$(curl "$SWITCHER_URL")
        if [[ "${version}" != "dev" ]]; then
          echo -e "\nUpdating switcher.json at ${SWITCHER_URL} for version ${version}."
          BASE_URL="$(jq -r '.[1].url|split("/")[0:-1]|join("/")' <<< $SWITCHER_CONTENT)"
          NEW_URL="${BASE_URL}/latest"

          # Extract the current dev entry
          DEV_ENTRY=$(jq '.[0]' <<< "${SWITCHER_CONTENT}")

          CURRENT_LATEST_VERSION=$(echo $(jq '.[1].version' <<< "${SWITCHER_CONTENT}") | tr -d '"')
          UPDATED_CURRENT_LATEST_ENTRY=$(jq --arg url "${BASE_URL}/${CURRENT_LATEST_VERSION}" '.[1] | .url = $url | del(.name)' <<< "$SWITCHER_CONTENT")
          
          # Create the new version entry with the "latest" tag
          NEW_ENTRY=$(jq -n --arg version "${version}" --arg url "$NEW_URL" --arg name "$version (latest)" \
            '{name: $name, version: $version, url: $url}')

          # Combine the entries in the desired order
          SWITCHER_CONTENT=$(jq --argjson dev_entry "$DEV_ENTRY" --argjson new_entry "$NEW_ENTRY" --argjson updated_current_latest "$UPDATED_CURRENT_LATEST_ENTRY" '[$dev_entry, $new_entry, $updated_current_latest] + .[2:]' <<< "$SWITCHER_CONTENT")
        fi
        SWITCHER_FILE="${version}/_static/switcher.json"
        echo "$SWITCHER_CONTENT" > "$SWITCHER_FILE"
        echo "${version}/_static/switcher.json has been updated successfully."
      else
        BASE_URL="${SWITCHER_URL%/latest*}"
        NEW_URL="${BASE_URL}/latest"

        if [[ "${version}" != "dev" ]]; then
          # Create the "latest" entry
          LATEST_ENTRY=$(jq -n --arg version "${version}" --arg url "$NEW_URL" --arg name "$version (latest)" \
            '{name: $name, version: $version, url: $url}')

          # Create the "dev" entry
          DEV_ENTRY=$(jq -n --arg version "dev" --arg url "${BASE_URL}/dev" --arg name "dev" \
            '{name: $name, version: $version, url: $url}')
          
          # Combine both
          UPDATED_SWITCHER_CONTENT=$(jq -n --argjson latest "$LATEST_ENTRY" --argjson dev "$DEV_ENTRY" \
            '[$dev, $latest]')
          
          # Add the initial switcher file
          SWITCHER_FILE="${version}/_static/switcher.json"
          echo "$UPDATED_SWITCHER_CONTENT" > "$SWITCHER_FILE"
          echo "${version}/_static/switcher.json has been updated successfully."
        fi
      fi
      
      # If this is a new release, update the link from /latest to it
      if [[ "${version}" != "dev" ]]; then
          echo -e "\nSetup link from ${version} to 'latest'."
          rm -f latest
          ln -sf ${version} latest
      fi
      
      # Stage the commit
      git add -A .
      echo -e "\nChanges to be applied:"
      git status
      # Configure git to be the GitHub Actions account
      git config user.email "github-actions[bot]@users.noreply.github.com"
      git config user.name "github-actions[bot]"
      echo -e "\nMaking a new commit:"
      git commit -m "$message"
      # Make the push quiet just in case there is anything that could leak
      # sensitive information.
      echo -e "\nPushing changes to gh-pages."
      git push -fq origin gh-pages 2>&1 >/dev/null
      echo -e "\nFinished uploading generated files."